package security

import (
	"context"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io/fs"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"sync"
	"time"
)

// VulnerabilityScanner provides automated vulnerability scanning capabilities
type AutomatedVulnerabilityScanner struct {
	scanners        map[string]VulnerabilityScanner
	rules           []ScanRule
	config          ScanConfig
	database        VulnerabilityDB
	results         []ScanResult
	notifications   NotificationService
	scheduler       ScanScheduler
	mu              sync.RWMutex
	isScanning      bool
	lastScanTime    time.Time
	totalVulns      int
	criticalVulns   int
	falsePositives  []string
}

// VulnerabilityScanner interface for different scanner types
type VulnerabilityScanner interface {
	GetName() string
	GetDescription() string
	GetScanTypes() []ScanType
	Scan(ctx context.Context, target ScanTarget) ([]ScanResult, error)
	Configure(config map[string]interface{}) error
	GetVersion() string
}

// ScanResult represents a vulnerability scan result
type ScanResult struct {
	ID              string            `json:"id"`
	ScannerName     string            `json:"scanner_name"`
	Timestamp       time.Time         `json:"timestamp"`
	Target          string            `json:"target"`
	VulnerabilityID string            `json:"vulnerability_id"`
	Title           string            `json:"title"`
	Description     string            `json:"description"`
	Severity        RiskLevel         `json:"severity"`
	Confidence      float64           `json:"confidence"`
	CVSS            float64           `json:"cvss"`
	CVE             string            `json:"cve,omitempty"`
	CWE             string            `json:"cwe,omitempty"`
	Category        VulnCategory      `json:"category"`
	Location        VulnLocation      `json:"location"`
	Evidence        ScanEvidence      `json:"evidence"`
	Remediation     string            `json:"remediation"`
	References      []string          `json:"references"`
	IsFalsePositive bool              `json:"is_false_positive"`
	Tags            []string          `json:"tags"`
	Metadata        map[string]string `json:"metadata"`
}

// ScanRule defines vulnerability detection rules
type ScanRule struct {
	ID          string           `json:"id"`
	Name        string           `json:"name"`
	Description string           `json:"description"`
	Category    VulnCategory     `json:"category"`
	Severity    RiskLevel        `json:"severity"`
	Pattern     string           `json:"pattern"`
	FileTypes   []string         `json:"file_types"`
	Condition   RuleCondition    `json:"condition"`
	Action      RuleAction       `json:"action"`
	Enabled     bool             `json:"enabled"`
	Author      string           `json:"author"`
	Created     time.Time        `json:"created"`
	Updated     time.Time        `json:"updated"`
	Version     string           `json:"version"`
}

// Configuration and types
type ScanConfig struct {
	ScanTypes          []ScanType        `json:"scan_types"`
	MaxConcurrentScans int              `json:"max_concurrent_scans"`
	ScanTimeout        time.Duration    `json:"scan_timeout"`
	ReportFormat       string           `json:"report_format"`
	OutputDirectory    string           `json:"output_directory"`
	IncludePatterns    []string         `json:"include_patterns"`
	ExcludePatterns    []string         `json:"exclude_patterns"`
	MinSeverity        RiskLevel        `json:"min_severity"`
	EnabledScanners    []string         `json:"enabled_scanners"`
	NotifyOnFindings   bool             `json:"notify_on_findings"`
	AutoRemediation    bool             `json:"auto_remediation"`
	FalsePositiveDB    string           `json:"false_positive_db"`
}

type ScanType string

const (
	ScanTypeStaticAnalysis    ScanType = "static_analysis"
	ScanTypeDependency        ScanType = "dependency"
	ScanTypeSecrets           ScanType = "secrets"
	ScanTypeLicense           ScanType = "license"
	ScanTypeContainer         ScanType = "container"
	ScanTypeInfrastructure    ScanType = "infrastructure"
	ScanTypeCompliance        ScanType = "compliance"
	ScanTypeCodeQuality       ScanType = "code_quality"
	ScanTypeSmartContract     ScanType = "smart_contract"
	ScanTypeCryptography      ScanType = "cryptography"
)

type VulnCategory string

const (
	VulnCategoryInjection          VulnCategory = "injection"
	VulnCategoryAuthentication     VulnCategory = "authentication"
	VulnCategoryAuthorization      VulnCategory = "authorization"
	VulnCategoryInputValidation    VulnCategory = "input_validation"
	VulnCategoryCryptography       VulnCategory = "cryptography"
	VulnCategoryBusinessLogic      VulnCategory = "business_logic"
	VulnCategoryInformationDisclosure VulnCategory = "information_disclosure"
	VulnCategoryDenialOfService    VulnCategory = "denial_of_service"
	VulnCategoryRaceCondition      VulnCategory = "race_condition"
	VulnCategoryMemoryCorruption   VulnCategory = "memory_corruption"
	VulnCategoryConfigurationError VulnCategory = "configuration_error"
	VulnCategoryHardcodedSecrets   VulnCategory = "hardcoded_secrets"
)

type VulnLocation struct {
	FilePath      string `json:"file_path"`
	LineNumber    int    `json:"line_number"`
	ColumnNumber  int    `json:"column_number"`
	FunctionName  string `json:"function_name"`
	ModuleName    string `json:"module_name"`
	CodeSnippet   string `json:"code_snippet"`
}

type ScanEvidence struct {
	Type        string            `json:"type"`
	Description string            `json:"description"`
	Data        map[string]string `json:"data"`
	Proof       string            `json:"proof"`
	Timestamp   time.Time         `json:"timestamp"`
}

type ScanTarget struct {
	Type        string            `json:"type"`
	Path        string            `json:"path"`
	URL         string            `json:"url"`
	Credentials map[string]string `json:"credentials"`
	Options     map[string]string `json:"options"`
}

type RuleCondition struct {
	Type       string `json:"type"`
	Expression string `json:"expression"`
	Context    string `json:"context"`
}

type RuleAction struct {
	Type       string            `json:"type"`
	Parameters map[string]string `json:"parameters"`
}

type VulnerabilityDB interface {
	GetVulnerability(id string) (*VulnerabilityInfo, error)
	SearchByPattern(pattern string) ([]VulnerabilityInfo, error)
	UpdateDatabase() error
	GetLastUpdate() time.Time
}

type VulnerabilityInfo struct {
	ID          string    `json:"id"`
	Title       string    `json:"title"`
	Description string    `json:"description"`
	Severity    RiskLevel `json:"severity"`
	CVSS        float64   `json:"cvss"`
	CVE         string    `json:"cve"`
	CWE         string    `json:"cwe"`
	Published   time.Time `json:"published"`
	Modified    time.Time `json:"modified"`
	References  []string  `json:"references"`
}

type NotificationService interface {
	SendVulnerabilityAlert(result ScanResult) error
	SendScanComplete(summary ScanSummary) error
	Configure(config NotificationConfig) error
}

type ScanScheduler interface {
	ScheduleScan(schedule string, target ScanTarget) error
	StartScheduler() error
	StopScheduler() error
}

// NewAutomatedVulnerabilityScanner creates a new vulnerability scanner
func NewAutomatedVulnerabilityScanner(config ScanConfig) *AutomatedVulnerabilityScanner {
	scanner := &AutomatedVulnerabilityScanner{
		scanners:       make(map[string]VulnerabilityScanner),
		rules:          make([]ScanRule, 0),
		config:         config,
		database:       NewMockVulnerabilityDB(),
		results:        make([]ScanResult, 0),
		notifications:  NewMockNotificationService(),
		scheduler:      NewMockScanScheduler(),
		falsePositives: make([]string, 0),
	}

	// Register built-in scanners
	scanner.RegisterScanner(NewStaticAnalysisScanner())
	scanner.RegisterScanner(NewDependencyScanner())
	scanner.RegisterScanner(NewSecretsScanner())
	scanner.RegisterScanner(NewCryptographyScanner())
	scanner.RegisterScanner(NewSmartContractScanner())

	// Load default vulnerability rules
	scanner.LoadDefaultRules()

	return scanner
}

// RegisterScanner registers a vulnerability scanner
func (avs *AutomatedVulnerabilityScanner) RegisterScanner(scanner VulnerabilityScanner) {
	avs.mu.Lock()
	defer avs.mu.Unlock()
	avs.scanners[scanner.GetName()] = scanner
}

// RunComprehensiveScan performs a comprehensive vulnerability scan
func (avs *AutomatedVulnerabilityScanner) RunComprehensiveScan(ctx context.Context, target ScanTarget) (*ScanReport, error) {
	avs.mu.Lock()
	if avs.isScanning {
		avs.mu.Unlock()
		return nil, fmt.Errorf("scan already in progress")
	}
	avs.isScanning = true
	avs.mu.Unlock()

	defer func() {
		avs.mu.Lock()
		avs.isScanning = false
		avs.lastScanTime = time.Now()
		avs.mu.Unlock()
	}()

	startTime := time.Now()
	report := &ScanReport{
		ID:        generateScanID(),
		StartTime: startTime,
		Target:    target,
		Config:    avs.config,
		Results:   make([]ScanResult, 0),
	}

	// Create semaphore for concurrent scanning
	sem := make(chan struct{}, avs.config.MaxConcurrentScans)
	var wg sync.WaitGroup
	var resultsMu sync.Mutex

	// Run enabled scanners
	for _, scannerName := range avs.config.EnabledScanners {
		scanner, exists := avs.scanners[scannerName]
		if !exists {
			continue
		}

		wg.Add(1)
		go func(s VulnerabilityScanner) {
			defer wg.Done()

			// Acquire semaphore
			sem <- struct{}{}
			defer func() { <-sem }()

			// Run scanner with timeout
			scanCtx, cancel := context.WithTimeout(ctx, avs.config.ScanTimeout)
			defer cancel()

			results, err := s.Scan(scanCtx, target)
			if err != nil {
				fmt.Printf("Scanner %s failed: %v\n", s.GetName(), err)
				return
			}

			// Filter and process results
			filteredResults := avs.filterResults(results)

			// Add to report
			resultsMu.Lock()
			report.Results = append(report.Results, filteredResults...)
			resultsMu.Unlock()
		}(scanner)
	}

	// Wait for all scanners to complete
	wg.Wait()

	report.EndTime = time.Now()
	report.Duration = report.EndTime.Sub(startTime)

	// Analyze and summarize results
	report.Summary = avs.generateSummary(report.Results)

	// Update internal state
	avs.mu.Lock()
	avs.results = append(avs.results, report.Results...)
	avs.totalVulns = len(avs.results)
	avs.criticalVulns = avs.countCriticalVulns(avs.results)
	avs.mu.Unlock()

	// Send notifications if enabled
	if avs.config.NotifyOnFindings && len(report.Results) > 0 {
		go avs.sendNotifications(report.Results, report.Summary)
	}

	return report, nil
}

// filterResults filters scan results based on configuration
func (avs *AutomatedVulnerabilityScanner) filterResults(results []ScanResult) []ScanResult {
	filtered := make([]ScanResult, 0)

	for _, result := range results {
		// Filter by minimum severity
		if !avs.meetsMinSeverity(result.Severity) {
			continue
		}

		// Check false positives
		if avs.isFalsePositive(result.ID) {
			result.IsFalsePositive = true
		}

		// Apply include/exclude patterns
		if !avs.matchesPatterns(result.Target) {
			continue
		}

		filtered = append(filtered, result)
	}

	return filtered
}

// meetsMinSeverity checks if severity meets minimum threshold
func (avs *AutomatedVulnerabilityScanner) meetsMinSeverity(severity RiskLevel) bool {
	severityLevels := map[RiskLevel]int{
		RiskInfo:     0,
		RiskLow:      1,
		RiskMedium:   2,
		RiskHigh:     3,
		RiskCritical: 4,
	}

	minLevel := severityLevels[avs.config.MinSeverity]
	currentLevel := severityLevels[severity]

	return currentLevel >= minLevel
}

// isFalsePositive checks if a result is a known false positive
func (avs *AutomatedVulnerabilityScanner) isFalsePositive(resultID string) bool {
	for _, fp := range avs.falsePositives {
		if fp == resultID {
			return true
		}
	}
	return false
}

// matchesPatterns checks if target matches include/exclude patterns
func (avs *AutomatedVulnerabilityScanner) matchesPatterns(target string) bool {
	// Check exclude patterns first
	for _, pattern := range avs.config.ExcludePatterns {
		matched, _ := regexp.MatchString(pattern, target)
		if matched {
			return false
		}
	}

	// If no include patterns, include by default
	if len(avs.config.IncludePatterns) == 0 {
		return true
	}

	// Check include patterns
	for _, pattern := range avs.config.IncludePatterns {
		matched, _ := regexp.MatchString(pattern, target)
		if matched {
			return true
		}
	}

	return false
}

// generateSummary generates a scan summary
func (avs *AutomatedVulnerabilityScanner) generateSummary(results []ScanResult) ScanSummary {
	summary := ScanSummary{
		TotalVulnerabilities: len(results),
		VulnerabilitiesByCategory: make(map[VulnCategory]int),
		VulnerabilitiesBySeverity: make(map[RiskLevel]int),
		VulnerabilityTypes: make(map[string]int),
	}

	for _, result := range results {
		summary.VulnerabilitiesByCategory[result.Category]++
		summary.VulnerabilitiesBySeverity[result.Severity]++
		summary.VulnerabilityTypes[result.VulnerabilityID]++
	}

	// Calculate risk score
	summary.RiskScore = avs.calculateRiskScore(results)

	return summary
}

// calculateRiskScore calculates overall risk score
func (avs *AutomatedVulnerabilityScanner) calculateRiskScore(results []ScanResult) float64 {
	if len(results) == 0 {
		return 0.0
	}

	riskWeights := map[RiskLevel]float64{
		RiskCritical: 10.0,
		RiskHigh:     5.0,
		RiskMedium:   2.0,
		RiskLow:      1.0,
		RiskInfo:     0.1,
	}

	totalRisk := 0.0
	for _, result := range results {
		weight := riskWeights[result.Severity]
		confidence := result.Confidence / 100.0
		totalRisk += weight * confidence
	}

	// Normalize to 0-100 scale
	maxPossibleRisk := float64(len(results)) * 10.0
	if maxPossibleRisk == 0 {
		return 0.0
	}

	return (totalRisk / maxPossibleRisk) * 100.0
}

// countCriticalVulns counts critical vulnerabilities
func (avs *AutomatedVulnerabilityScanner) countCriticalVulns(results []ScanResult) int {
	count := 0
	for _, result := range results {
		if result.Severity == RiskCritical {
			count++
		}
	}
	return count
}

// sendNotifications sends vulnerability notifications
func (avs *AutomatedVulnerabilityScanner) sendNotifications(results []ScanResult, summary ScanSummary) {
	// Send individual alerts for critical/high severity findings
	for _, result := range results {
		if result.Severity == RiskCritical || result.Severity == RiskHigh {
			if err := avs.notifications.SendVulnerabilityAlert(result); err != nil {
				fmt.Printf("Failed to send vulnerability alert: %v\n", err)
			}
		}
	}

	// Send scan completion summary
	if err := avs.notifications.SendScanComplete(summary); err != nil {
		fmt.Printf("Failed to send scan completion notification: %v\n", err)
	}
}

// LoadDefaultRules loads default vulnerability detection rules
func (avs *AutomatedVulnerabilityScanner) LoadDefaultRules() {
	defaultRules := []ScanRule{
		{
			ID:          "hardcoded_password",
			Name:        "Hardcoded Password",
			Description: "Detects hardcoded passwords in source code",
			Category:    VulnCategoryHardcodedSecrets,
			Severity:    RiskHigh,
			Pattern:     `(?i)(password|pwd|pass)\s*[:=]\s*["'][^"']*["']`,
			FileTypes:   []string{".go", ".js", ".py", ".java"},
			Enabled:     true,
			Author:      "ShareHODL Security Team",
			Created:     time.Now(),
			Updated:     time.Now(),
			Version:     "1.0",
		},
		{
			ID:          "sql_injection",
			Name:        "SQL Injection",
			Description: "Detects potential SQL injection vulnerabilities",
			Category:    VulnCategoryInjection,
			Severity:    RiskHigh,
			Pattern:     `(?i)query\s*\+|\$.*query|SELECT.*\+|INSERT.*\+`,
			FileTypes:   []string{".go", ".js", ".py", ".java"},
			Enabled:     true,
			Author:      "ShareHODL Security Team",
			Created:     time.Now(),
			Updated:     time.Now(),
			Version:     "1.0",
		},
		{
			ID:          "weak_crypto",
			Name:        "Weak Cryptography",
			Description: "Detects use of weak cryptographic algorithms",
			Category:    VulnCategoryCryptography,
			Severity:    RiskMedium,
			Pattern:     `(?i)(md5|sha1|des|rc4)\s*\(`,
			FileTypes:   []string{".go", ".js", ".py", ".java"},
			Enabled:     true,
			Author:      "ShareHODL Security Team",
			Created:     time.Now(),
			Updated:     time.Now(),
			Version:     "1.0",
		},
		{
			ID:          "insecure_random",
			Name:        "Insecure Random",
			Description: "Detects use of insecure random number generators",
			Category:    VulnCategoryCryptography,
			Severity:    RiskMedium,
			Pattern:     `(?i)math\.rand|Random\(\)|rand\(\)`,
			FileTypes:   []string{".go", ".js", ".py", ".java"},
			Enabled:     true,
			Author:      "ShareHODL Security Team",
			Created:     time.Now(),
			Updated:     time.Now(),
			Version:     "1.0",
		},
	}

	avs.rules = append(avs.rules, defaultRules...)
}

// GetScanStatus returns current scan status
func (avs *AutomatedVulnerabilityScanner) GetScanStatus() ScanStatus {
	avs.mu.RLock()
	defer avs.mu.RUnlock()

	return ScanStatus{
		IsScanning:      avs.isScanning,
		LastScanTime:    avs.lastScanTime,
		TotalVulns:      avs.totalVulns,
		CriticalVulns:   avs.criticalVulns,
		ScannersEnabled: len(avs.config.EnabledScanners),
		RulesLoaded:     len(avs.rules),
	}
}

// Supporting types and implementations

type ScanReport struct {
	ID        string       `json:"id"`
	StartTime time.Time    `json:"start_time"`
	EndTime   time.Time    `json:"end_time"`
	Duration  time.Duration `json:"duration"`
	Target    ScanTarget   `json:"target"`
	Config    ScanConfig   `json:"config"`
	Results   []ScanResult `json:"results"`
	Summary   ScanSummary  `json:"summary"`
}

type ScanSummary struct {
	TotalVulnerabilities      int                    `json:"total_vulnerabilities"`
	VulnerabilitiesByCategory map[VulnCategory]int   `json:"vulnerabilities_by_category"`
	VulnerabilitiesBySeverity map[RiskLevel]int      `json:"vulnerabilities_by_severity"`
	VulnerabilityTypes        map[string]int         `json:"vulnerability_types"`
	RiskScore                 float64                `json:"risk_score"`
}

type ScanStatus struct {
	IsScanning      bool      `json:"is_scanning"`
	LastScanTime    time.Time `json:"last_scan_time"`
	TotalVulns      int       `json:"total_vulnerabilities"`
	CriticalVulns   int       `json:"critical_vulnerabilities"`
	ScannersEnabled int       `json:"scanners_enabled"`
	RulesLoaded     int       `json:"rules_loaded"`
}

type NotificationConfig struct {
	Email    EmailConfig    `json:"email"`
	Slack    SlackConfig    `json:"slack"`
	Webhook  WebhookConfig  `json:"webhook"`
}

type EmailConfig struct {
	Enabled    bool     `json:"enabled"`
	Recipients []string `json:"recipients"`
	SMTPServer string   `json:"smtp_server"`
	Username   string   `json:"username"`
	Password   string   `json:"password"`
}

type SlackConfig struct {
	Enabled bool   `json:"enabled"`
	Webhook string `json:"webhook"`
	Channel string `json:"channel"`
}

type WebhookConfig struct {
	Enabled bool   `json:"enabled"`
	URL     string `json:"url"`
	Headers map[string]string `json:"headers"`
}

// Mock implementations for demo

type MockVulnerabilityDB struct{}

func NewMockVulnerabilityDB() *MockVulnerabilityDB {
	return &MockVulnerabilityDB{}
}

func (mvdb *MockVulnerabilityDB) GetVulnerability(id string) (*VulnerabilityInfo, error) {
	return nil, fmt.Errorf("vulnerability not found")
}

func (mvdb *MockVulnerabilityDB) SearchByPattern(pattern string) ([]VulnerabilityInfo, error) {
	return []VulnerabilityInfo{}, nil
}

func (mvdb *MockVulnerabilityDB) UpdateDatabase() error {
	return nil
}

func (mvdb *MockVulnerabilityDB) GetLastUpdate() time.Time {
	return time.Now()
}

type MockNotificationService struct{}

func NewMockNotificationService() *MockNotificationService {
	return &MockNotificationService{}
}

func (mns *MockNotificationService) SendVulnerabilityAlert(result ScanResult) error {
	fmt.Printf("ALERT: %s vulnerability found: %s\n", result.Severity, result.Title)
	return nil
}

func (mns *MockNotificationService) SendScanComplete(summary ScanSummary) error {
	fmt.Printf("Scan completed: %d vulnerabilities found (Risk Score: %.1f)\n", summary.TotalVulnerabilities, summary.RiskScore)
	return nil
}

func (mns *MockNotificationService) Configure(config NotificationConfig) error {
	return nil
}

type MockScanScheduler struct{}

func NewMockScanScheduler() *MockScanScheduler {
	return &MockScanScheduler{}
}

func (mss *MockScanScheduler) ScheduleScan(schedule string, target ScanTarget) error {
	return nil
}

func (mss *MockScanScheduler) StartScheduler() error {
	return nil
}

func (mss *MockScanScheduler) StopScheduler() error {
	return nil
}

// Helper functions

func generateScanID() string {
	timestamp := time.Now().Format("20060102150405")
	hash := sha256.Sum256([]byte(timestamp + "vuln_scan"))
	return "scan_" + hex.EncodeToString(hash[:8])
}

// Scanner implementations would be added here...